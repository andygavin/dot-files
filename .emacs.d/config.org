* Introduction
The number of times I've started emacs configuration from scratch is
at least the number of places I've worked multiplied by two.  There's
no single reason for starting again, but besides commerical
restrictions on what you can take with you, I've found that my
configuration can often be an number of hacks that evolved to solve
problems at particular times. When emacs is upgraded or I move the
effort doesn't seem worth it to work out what I intended previously
and I throw something together to meet the job in hand.

So this is a different approach, which had greater scope for
structuring the intialisation parameters with an explaination of why I
did it at the time.


** Typical Emacs Configuration
Typical emacs configuration does not have to be this way.  You would
normally find in people's ~.emacs~ file and ~.emacs.d/~ directory a
collections of .el files which are the Emacs Lisp configuration for
the editor. This configuration is inspired by a number of
configurations on the internet, that use org-mode's babel package to
literately write the configuration.  This package will extract the
configuration from this documentation and optionally compile it.  This
configuration is unlikely to work on earlier versions of emacs that
don't have the emacs package manager, or a relavtively recent version
of org-mode.  It would be possible to modify it to use local versions
of these things and load them in the bootstrap.

To enable this we still will need to bootstrap ~org-babel~ this is done using:

#+begin_src emacs-lisp  :tangle no
(require 'package)
(require 'org)
(defconst init/emacsd "~/.emacs.d/")
(org-babel-load-file "~/.emacs.d/config.org")
#+END_SRC

The bootstrap is placed in the ~.emacs.d/init.el~ file, this file is
the file that is normally loaded by emacs on startup\mdash a more
modern version of the old ~.emacs~ file.  Aquamacs, however, has a
slightly modified configuration system where, should the built-in
preferences be used, I've found only the ~.emacs~ file is read. To
avoid this I'm exclusively configuring it as I do other emacsen: via
these files alone.

As I'm using aquamacs on the mac, I'm setting a constant for the
~~/.emacs.d/init.el~ directory.

** Initial Setup

There are a few things we want to do early to clean up the window.
For graphical versions of emacs they often have toolbars and menus.
We turn these off early to avoid them from appearing then
disappearing.  Guarding each switch is a predicate to ensure that
the parameter exists in the environment:

#+begin_src emacs-lisp
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (custom-variable-p 'inhibit-splash-screen)  (setq inhibit-splash-screen t))
(if (custom-variable-p 'inhibit-startup-message)
                 (setq inhibit-startup-message t))
#+end_src

** Ensure we have the packages we want
To assume the least about the what has been shipped with the version
of emacs we have we will use the now standard package manager.  First
we will set up some decent well known repositories, these are used in
order. We assume that emacs includes the its default.

#+begin_src emacs-lisp
(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
(setq package-user-dir (concat init/emacsd "elpa"))
(add-to-list 'load-path (concat init/emacsd "site-lisp"))
#+end_src

Here we have also set where the package manager will place the
installation of the packages, and an area for custom lisp
~site-lisp~. The packages we want to ensure we have are:

#+begin_src emacs-lisp
(defvar init/packages '(
                        ido-ubiquitous
                        ace-jump-mode
                        epl
                        yasnippet
                        diminish
                        use-package
                        cider
                        company
                        hl-sexp
                        clj-refactor
                        let-alist
                        flycheck-clojure
                        flycheck-pos-tip
                        flycheck
                        feature-mode
                        gist
                       ;; breadcrumb
                        go-mode
                        graphviz-dot-mode
                        haskell-mode
                        htmlize
                        markdown-mode
                        o-blog
                        guide-key
                        org
                        paredit
                        restclient
                        smex
                        solarized-theme
                        web-mode
                        writegood-mode
                        rust-mode
                        exec-path-from-shell
                        zenburn-theme
                        dakrone-theme
                        s
                        epg
                        twittering-mode
                        sqlplus
                        linum
                        ;; aggressive-indent
                        regex-tool
                        world-time-mode
                        perl-completion
                        polymode
                        rust-mode
                        flycheck-rust
                        plsql
                        magit
                        protobuf-mode
                        sx
                        sqlplus
                        ggtags
                        undo-tree
                        ) "Default packages")
#+end_src

To ensure these packages are loaded lets define a couple of functions. One which ensures as single package is installed, the other which takes a list and handles any loading errors.

#+begin_src emacs-lisp
(defun ensure-package-installed (package &optional min-version no-refresh)
  "Install given PACKAGE, optionally requiring MIN-VERSION.
If NO-REFRESH is non-nil, the available package lists will not be
re-downloaded in order to locate PACKAGE."
  (if (package-installed-p package min-version)
      t
    (if (or (assoc package package-archive-contents) no-refresh)
        (package-install package)
      (progn
        (package-refresh-contents)
        (ensure-package-installed package min-version t)))))



(defun ensure-packages-installed (package-list)
  "Ensure that packages are installed in this emacs installation"
  (dolist (package package-list)
    (condition-case ex
        (ensure-package-installed package)
      ('error (warn (concat "Failed to install package " (symbol-name package)))))))

#+end_src

Now we can ensure that our list of packages are installed:

#+begin_src emacs-lisp
(setq package-enable-at-startup nil) ; Don't initialize later as well
(package-initialize)
(ensure-packages-installed init/packages)
;;(package-initialize)
#+end_src

* General Editing
Before we start setting up different modes for specific operations and
languages first we'll set up some global settings and try and
normalise the settings across different platforms.

** Whitespace
Tabs are an acryonism, left over from an age of teletype printers.  We
want spaces instead, and a lot less than eight characters.  W
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)

#+end_src


We also turn on whitespace visualisation for most modes, using the
white-space mode. We're using it to avoid the use of tabs and
highlight end-of-line whitespace.
#+begin_src emacs-lisp
(whitespace-mode 1)
(setq whitespace-style '(indentation::space
                         space-after-tab
                         space-before-tab
                         trailing
                         lines-tail
                         tab-mark
                         face
                         tabs))
#+end_src
I don't think we ever have a mode where we care about trailing
whitespace so we'll get the editor to tidy it up.

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Some tools like having a newline at the end of a file, we can arrange
emacs to ensure this:

#+BEGIN_SRC emacs-lisp
(setq mode-require-final-newline t)
#+END_SRC

** Encoding
Most environments I work on now are 8-bit clean. Emacs interaction
with the clipboards in these environments default to UTF-8 and
suprises occur occasionally if encoding of extended characters are not
UTF-8.  So we're setting our default encoding, and avoiding the
strange tab character:

#+begin_src emacs-lisp
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

The other aspect of encoding is differing conventions around the
line-endings between platforms.

#+begin_src emacs-lisp
(defun unix-file ()
  "Change the current buffer to Latin 1 with Unix line-ends."
  (interactive)
  (set-buffer-file-coding-system 'utf8-unix t))
(defun dos-file ()
  "Change the current buffer to Latin 1 with DOS line-ends."
  (interactive)
  (set-buffer-file-coding-system 'utf8-dos t))
(defun mac-file ()
  "Change the current buffer to Latin 1 with Mac line-ends."
  (interactive)
  (set-buffer-file-coding-system 'utf8-mac t))
#+end_src

Changing encodings to other types is achievable through emacs keys: ^X
RET f.

** Buffer navigation
Winner mode is for recoving windows layouts, still need to fix this
for aquamacs.

#+begin_src emacs-lisp
  (when (fboundp 'winner-mode)
    (require 'winner)
    (setq winner-dont-bind-my-keys t) ;; default bindings conflict with org-mode

    (global-set-key (kbd "<C-s-left>") 'winner-undo)
    (global-set-key (kbd "<C-s-right>") 'winner-redo)
    (winner-mode t) ;; turn on the global minor mode
    )
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
  (when (fboundp 'ibuffer)
    (global-set-key (kbd "C-x C-b") 'ibuffer)
    (autoload 'ibuffer "ibuffer" "List buffers." t))

  (set-fringe-mode '(5 .  5))

  (setq ido-enable-flex-matching t)
  (setq ido-show-dot-for-dired nil)
  (ido-mode 1)
  (ido-ubiquitous-mode 1)
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
  (global-subword-mode 1)
  (global-set-key (kbd "C-z") 'undo)
  (require 'uniquify)
  (fset 'yes-or-no-p 'y-or-n-p)

  (defun iwb ()
    "indent whole buffer"
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max)))

  (global-set-key [(meta up)] 'move-line-up)
  (global-set-key [(meta down)] 'move-line-down)

  (defun move-line (&optional n)
    "Move current line N (1) lines up/down leaving point in place."
    (interactive "p")
    (when (null n)
      (setq n 1))
    (let ((col (current-column)))
      (beginning-of-line)
      (next-line 1)
      (transpose-lines n)
      (previous-line 1)
      (forward-char col)))

  (defun move-line-up (n)
    "Moves current line N (1) lines up leaving point in place."
    (interactive "p")
    (move-line (if (null n) -1 (- n))))

  (defun move-line-down (n)
    "Moves current line N (1) lines down leaving point in place."
    (interactive "p")
    (move-line (if (null n) 1 n)))

  (setq truncate-partial-width-windows nil)
  (setq default-truncate-lines nil)

  (setq
   enable-recursive-minibuffers nil      ;;  don't allow mb cmds in the mb
   max-mini-window-height 3              ;;  max 3 lines
   minibuffer-scroll-window t            ;;  C-M-v scrolls....
   resize-mini-windows t)

#+end_src
*** Smex
@@html:<kbd>M-x</kbd>@@ enhancement to extend ido to the M-x function.  These are the keybindings frfrom the page: [[https://github.com/nonsequitur/smex/][Smex Github page]]
#+begin_src emacs-lisp
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
;; This is your old M-x.
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+end_src


** Setting for the Mac

#+begin_src emacs-lisp
(require 'exec-path-from-shell)
(when (memq window-system '(mac ns))
  (global-set-key (kbd "M-3") '(lambda () (interactive) (insert "#")))
  (exec-path-from-shell-initialize)
  (global-set-key (kbd "<f8>") 'mac-toggle-max-window))
#+end_src

** Setup for windows
One of the issues that can loose emacs users is the copy and paste
does not conform to the Windows conventional keys.  Although the keys
can be rebound using ~cua~ this then makes some of the emacs
keybindings unavailable or more error prone. Aquamacs suffers from
this problem less, because the convention for cut and paste uses the
command key, rather than the control key. A better compromise on
window is to free up some of the other modifier keys available for use
by emacs.  These are:
  * Caps-lock
  * The Application Key: which normally has a little menu on it
  * The left and right windows keys
Freeing up these keys as modifiers opens up far more keys for binding
to custom functions as well as supporting some of the Windows
conventions, albeit on the windows keys:

#+begin_src emacs-lisp
(when (string-equal system-type "windows-nt")
    (setq w32-enable-caps-lock nil
          w32-enable-num-lock nil
          w32-apps-modifier 'hyper
          w32-lwindow-modifier 'super
          w32-rwindow-modifier 'super
          w32-pass-lwindow-to-system nil
          w32-pass-rwindow-to-system nil

          )
    (define-key global-map [?\s-x] 'kill-region)
    (define-key global-map [?\s-x] 'kill-ring-save)
    (define-key global-map [?\s-x] 'yank)
    )
#+end_src
** Themes

#+begin_src emacs-lisp
(load-theme 'dakrone t)
#+end_src
** Backups
I'd prefer not to place backups in the current directory when saving
files.  Emacs provides a facility to place the backups of files edited
and the autosave files in a different directory.  Here we're backing
up and autosaving all files edited into a single backup directory.

#+begin_src emacs-lisp
(defvar user-temporary-file-directory
  (concat init/emacsd "tmp/"))

(make-directory user-temporary-file-directory t)
(setq backup-directory-alist
      `(("." . ,user-temporary-file-directory) (,tramp-file-name-regexp nil))
      version-control t        ; Use version numbers for backups
      kept-new-versions 16     ; Number of newest versions to keep
      kept-old-versions 2      ; Number of oldest versions to keep
      delete-old-versions t    ; Ask to delete excess backup versions?
      backup-by-copying-when-linked t) ; Copy linked files, don't rename.
(setq auto-save-list-file-prefix
      (concat user-temporary-file-directory ".auto-saves-"))
(setq auto-save-file-name-transforms
      `((".*" ,user-temporary-file-directory t)))

#+end_src
** Emacs Shell
It's possible to configure some commands in the emacs shell to produce
their results in another buffer by setting ~eshell-visual-commands~.
#+begin_src emacs-lisp
(eval-after-load "em-term"
  '(progn
     (add-to-list 'eshell-visual-subcommands '("git" "log" "diff" "show")
     (add-to-list 'eshell-visual-commands "ssh"))))
#+end_src

** World Time

#+begin_src emacs-lisp
(setq display-time-world-list '(
                                ("GMT0BST" "London")
                                ("CET-1CDT" "Paris")
                                ("HKT" "Hong-Kong")
                                ))

#+end_src
** Bookmarks

#+begin_src emacs-lisp
;;(require 'breadcrumb)
;;(autoload 'bc-set               "breadcrumb" "Set bookmark in current point."   t)
;;(autoload 'bc-previous          "breadcrumb" "Go to previous bookmark."         t)
;;(autoload 'bc-next              "breadcrumb" "Go to next bookmark."             t)
;;(autoload 'bc-local-previous    "breadcrumb" "Go to previous local bookmark."   t)
;;(autoload 'bc-local-next        "breadcrumb" "Go to next local bookmark."       t)
;;(autoload 'bc-goto-current      "breadcrumb" "Go to the current bookmark."      t)
;;(autoload 'bc-list              "breadcrumb" "List all bookmarks in menu mode." t)
;;(autoload 'bc-clear             "breadcrumb" "Clear all bookmarks."             t)


(setq
  bookmark-default-file (concat init/emacsd "bookmarks")
  bookmark-save-flag 1) ;; autosave each change
#+end_src

** Completion
We use the yasnippet templating engine to provide template, but this
is provided through company mode to provide greater flexabilty, which
provides other backends including finding words in the current buffer.

The vesion of yas I have is autoloaded on the minor mode or global
mode, so we'll load the tabled on the first time a mode uses the
snippets.


#+begin_src emacs-lisp
(setq yas-snippet-dirs '("~/.emacs.d/snippets"))
(yas-global-mode 0)
(yas-reload-all)
#+end_src
** Usability
Keyguide helps for areas of the key-bindings that I don't always
remember by popping up the possible completions.
#+BEGIN_SRC emacs-lisp
(require 'guide-key)
(setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x 3" "C-x 8" "C-x 5"))
(guide-key-mode 1)  ; Enable guide-key-mode
#+END_SRC
** Improved Undo
Use undo-tree to improve undo behaviour

#+BEGIN_SRC emacs-lisp
(require 'undo-tree)
(global-undo-tree-mode)
#+END_SRC

** Enable all features
There some features of emacs which are not enabled by default. We want
these features to enable these.

#+BEGIN_SRC emacs-lisp
;; Run at full power please
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC
* Programming Lisps
One of the reasons that I wanted to reconfigure my emacs settings this
time round was the adoption of Clojure.  Clojure's tooling and
community has driven some interesting development in the emacs
community and is the most widely used editor in the community,
although it now has stiff competition from both Cursive (Idea's plugin
for clojure) and Lighttable. Emacs history support for lisp
programming has been an advantage but there is a degree in the
flexibility of support.  In other languages moving to emacs would
sometimes mean sacificing some of the immedate feedback given by a
more dedicated environment and the ability to apply semi-automatic
refactoring.  For these two things at least, it's not the case for
clojure.
Often what puts people off list is the brackets, besides the visual
appeal this is perhaps the annoyance of having to get the to match
up.  Here we use some packages to make this more intuitive.
** Paredit
Paredit changes the way that the standard movement keys work when in
parenthesis. Using the arrow keys with different modifier keys
manipulates the environment around the cursor in useful ways that
avoids errorprone typing.  So splicing, joining and removing sexps
becauses much easier.

#+begin_src emacs-lisp
(require 'paredit)
(add-hook 'lisp-mode-hook #'paredit-mode)
(add-hook 'emacs-lisp-mode-hook #'paredit-mode)
(add-hook 'clojure-mode-hook #'paredit-mode)
(add-hook 'cider-repl-mode-hook #'paredit-mode)

(with-eval-after-load 'eldoc
  (eldoc-add-command 'paredit-backward-delete 'paredit-close-round))
#+end_src

** Highlight Sexp
Besides ensuring when you edit an expression the right number of open
and close braces are present the thing that is useful is to be able to
quickly see if brackets match up. Emacs has a number of options for
this.  Here we have selected to use the ~hl-sexp~ package which will
/highlight/ the environment that the cursor is in.
#+begin_src emacs-lisp
;; hl-sexp: minor mode to highlight s-expression
(require 'hl-sexp)

(add-hook 'clojure-mode-hook #'hl-sexp-mode)
(add-hook 'lisp-mode-hook #'hl-sexp-mode)
(add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode)
#+end_src

* Syntax Checking
Syntax checking in emacs has evolved as there are different options
depending on the language.  For clojure the best at the moment is
~flycheck~.

#+begin_src emacs-lisp

(require 'flycheck)

(eval-after-load 'flycheck '(flycheck-clojure-setup))

(add-hook 'after-init-hook #'global-flycheck-mode)
(eval-after-load 'flycheck
  '(setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages))

#+end_src

Here we enable flycheck for clojure but also use another feature that
displays the flycheck errors in-buffer more like a Java IDE. Otherwise
these errors would appear in the minibuffer obscuring other useful
feeback from eldoc.

** Clojure: Cider Configuration
Cider is the clojure mode of choice. First we set up lein and our
preferences for the REPL.
#+begin_src emacs-lisp
(setq cider-lein-command (concat (or (getenv "LEIN_HOME") "~") "/bin/lein")
      cider-repl-history-file (concat init/emacsd "/cider-history")
      cider-repl-use-pretty-printing t
      cider-repl-use-clojure-font-lock t
      cider-repl-result-prefix ";; => "
      cider-repl-wrap-history t
      cider-repl-history-size 3000)

(add-hook 'cider-repl-mode-hook #'company-mode)
#+end_src

For editing we set up eldoc and configure completion. We are also
electing to not show the error buffer when there is a cider-stack
trace.  The error will be available in the background should we need
to userstand what has happened.

Refactoring in enabled and bound to a key.

#+begin_src emacs-lisp
;; eldoc for clojure
(add-hook 'cider-mode-hook #'eldoc-mode)


;; error buffer not popping up
(setq cider-show-error-buffer nil)

;; company mode for completion

(add-hook 'cider-mode-hook #'company-mode)

(add-hook 'clojure-mode-hook
	  (lambda ()
	    (clj-refactor-mode 1)
	    ;; insert keybinding setup here
	    (cljr-add-keybindings-with-prefix "C-c RET")))

(add-hook 'clojure-mode-hook #'yas-minor-mode)


;; no auto sort
(setq cljr-auto-sort-ns nil
      cljr-favor-prefix-notation nil)

#+end_src

** Autoinserting templates
I find autoinserting useful as well as templates.  These insert intial
content into the buffer when the file is new
#+begin_src emacs-lisp
(require 'autoinsert)
(add-hook 'find-file-hook 'auto-insert)
#+end_src

* Perl Development

Occasionally I still use perl for where bash doesn't cut it.  I've
used it enough over the years for it to be useful for the odd bit of
bit of generation, file manipulation or build scripting. This is quite
close to it's original purpose for extracting and reporting over large
datasets. It still seems good for the quick and ad-hoc.

CPerl is a pretty good ide for perl, it gives in edit feedback on
where you have got to.

#+begin_src emacs-lisp
(add-to-list 'load-path (concat init/emacsd "/pde/lisp/"))
(load "pde-load")
(add-hook 'cperl-mode-hook #'yas-minor-mode)
#+end_src

* Rust

Rust looks to be a promising language, with some innovative features.  Many say that it's up
against Go as a more modern system language, but still suffers from breaking language changes.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
(add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
#+end_src

I've yet to look at racer to improve the link to the rust documentation.

* Haskell mode
I've not used this haskell configuration much, it originates in a 10
minute setup before a Haskell workshop at FPDays 2011 in the brief
setup period in the class.  Because of the install path this only
works on my macbook for the moment.
#+begin_src emacs-lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
(add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
(setq haskell-program-name "/usr/bin/ghci")
#+end_src

* Oracle Development
Occasionally work has meant I will do some pl/sql development, and the
development of stored procedures. To facilitiate this emacs has some
support for developing stored procedure blocks with the ~plsql-mode~.
Although this is quite old and somewhat buggy, it still helps with
layout.  Here we use the recommended suffixes to open sql in the plsql mode.

#+begin_src emacs-lisp
(setq auto-mode-alist
          (append
           '(("\\.\\(p\\(?:k[bg]\\|ls\\)\\|sql\\)\\'" . plsql-mode))
 auto-mode-alist))
(autoload 'plsql-mode "plsql" "Oracle Pl/SQL mode" t)
(add-hook 'plsql-mode-hook (lambda ()
            (company-mode)
            (yas-minor-mode)
            (set (make-local-variable 'company-backends)
               '((company-dabbrev-code
                  company-keywords
                  company-yasnippet)))))
#+end_src
* C/C++ Development
An attempt at a rich configuration for c/c++ environments using the
inbuild semantic capabilities.  First require the libraries we would like.

#+BEGIN_SRC emacs-lisp
(require 'cc-mode)
(require 'semantic)
(require 'ede)
(require 'ggtags)
#+END_SRC
Semantic uses some background activities and functions that only
operate on semantic enabled buffers.
#+BEGIN_SRC emacs-lisp
  (setq semantic-default-submodes
        '(global-semanticdb-minor-mode
          global-semantic-idle-scheduler-mode
          global-semantic-stickyfunc-mode))
#+END_SRC
We then enable semantic on c/c++ buffers and fix some other aspects of
the buffers.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook (lambda ()
 (semantic-mode)
 (ede-minor-mode)
 (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
              (ggtags-mode 1))))

(define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
(define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
(define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
(define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
(define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
(define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)

(define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark)

#+END_SRC
* Tweeting
I've never been a great tweeter, but occasionally I've used emacs as
my twitter-client.
#+begin_src emacs-lisp
(setq twittering-tinyurl-service 'goo.gl)
;;(setq twittering-bitly-login "@andy_gavin")
;;(setq twittering-bitly-api-key "")
#+end_src

* Stackoverflow
I'm using ~sx~ to read and contribute to stackoverflow, this allows fast
interaction and I find it can help build up my local notes in
~org-mode~. Also there's reasonable interaction when in-buffer to look
for answers or post questions. The mode uses stack-overflow's API
which requires a key.  To set this call the ~sx-authenticate~
function. The mode has a [[http://stackapps.com/questions/3950/sx-stack-exchange-for-emacs][StackApps page]].

* XML

#+begin_src emacs-lisp
(require 'nxml-mode)
(require 'soap-client)
(setq auto-mode-alist
      (cons '("\\.\\(xml\\|xsl\\|rng\\|html\\|xhtml\\)\\'" . nxml-mode)
      auto-mode-alist))

;;(setq nxml-slash-auto-complete-flag t)
;;(let (
;;      (schema-dir (concat (config-get-module-dir "nxml") "schemas" ))
;;      )
;;  (add-to-list 'rng-schema-loader-alist '( "build.xml" . (concat schema-dir "/ant.rnc")))
;;  )

;;(if (and (iswindows) window-system)
;;    (global-set-key [(super return)] 'nxml-complete)
;;)
(setq popcmp-group-alternatives t)

(unify-8859-on-decoding-mode)

(fset 'xml-mode 'nxml-mode)
(fset 'sgml-mode 'nxml-mode)
(fset 'html-mode 'nxml-mode)


#+end_src

* Org Mode

Although we're using org-mode to read this file, it is a large package
rich with organisational features. Here we are loading:
 - org-capture :: capture tasks, todos.
 - org-crypt :: to keep secrets like passwords in crypted sections
 - org-feed :: Rss like news feeds.

#+begin_src emacs-lisp
(require 'org)
(require 'org-capture)
(require 'org-compat)
(require 'org-crypt)
(require 'org-feed)
#+end_src

We can also set up support for other programming languages:
#+BEGIN_SRC emacs-lisp

(eval-after-load 'org-babel
  (org-babel-do-load-languages
     'org-babel-load-languages
     '((clojure . t)
       (sh . t)
       (dot . t)
       (mscgen . t) ;; message seq charts
       (sql . t)
       (calc . t)
       (emacs-lisp . t)
       (plantuml . t)
       (ditaa . t))))

(setq org-modules nil)

#+END_SRC
** Literate programming in org-mode

Org-babel provides the ability to write literate programming, as this
file.  However syntax hilighting and other support from programming
modes isn't there.  Making the experience a poorer version editing
dedicated source files.  There have been some attempts to mix modes
with org-mode to allow for switching in the same buffer. I tried poly
mode:

#+begin_src emacs-lisp :tangle no
(require 'polymode)
(require 'poly-org)

(add-to-list 'auto-mode-alist '("\\.org" . poly-org-mode))
#+end_src

This does not work as it attempts to give the buffer two major modes
using indirect buffers.  Instead I'll look at outshine
https://github.com/tj64/outshine and outorg
https://github.com/tj64/outorg which apparently gives views onto the
literate org files.
** Agenda
Org mode has a comprehsive and flexible agenda and todo system.  This
can help to stay organised.  We can set up the initial buffer to be
the week's agenda:
#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice (lambda ()
     (org-agenda-list)
     (get-buffer "*Org Agenda*")))
#+END_SRC
There are some calendar integrations that I need to work through.
#+BEGIN_SRC emacs-lisp

(setq org-agenda-include-diary t)

#+END_SRC
** Capturing notes
This section needs sorting out, is some ported remember templates and
experimentation.
#+begin_src emacs-lisp

(setq org-default-notes-file (concat org-directory "/capture.org"))
(define-key global-map "\C-cc" 'org-capture)

(setq org-capture-templates
      `(("t" "Todo" entry (file+headline ,(concat org-directory "/gtd.org") "Tasks")
         "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree ,(concat org-directory "/journal.org"))
         "* %?\nEntered on %U\n  %i\n  %a")
        ("b" "Article Capture" entry (file+olp ,(concat org-directory "/readingList.org"))
        (file ,(concat init/emacsd "templates/reading.org"))
        :prepend t)))

(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)" "CANCELLED(c)")
        (sequence "TASK(f)" "|" "DONE(d)")
        (sequence "MAYBE(m)" "|" "CANCELLED(c)")))

(setq org-todo-keyword-faces
      '(("TODO" . (:foreground "DarkOrange1" :weight bold))
        ("MAYBE" . (:foreground "sea green"))
        ("DONE" . (:foreground "light sea green"))
        ("CANCELLED" . (:foreground "forest green"))
        ("TASK" . (:foreground "blue"))))

#+END_SRC

** Diagrams

#+BEGIN_SRC emacs-lisp
  (setq org-plantuml-jar-path
        (expand-file-name (concat init/emacsd "/libs/plantuml.jar")))

  (setq org-ditaa-jar-path
        (expand-file-name (concat init/emacsd "/libs/ditaa0_9.jar")))

  (defun org-insert-link-as-file ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-insert-link)))

  (add-hook 'org-load-hook
            (lambda ()
              (define-key org-mode-map (kbd "C-c C-g") 'org-insert-link-as-file)
              (define-key org-mode-map [ (super t) ] 'org-table-create-or-convert-from-region)
              (define-key org-mode-map [ (super c) ] 'org-codeblock-region)
              (whitespace-mode 0)
              (setq org-startup-indented t
                    org-hide-leading-stars t
                    org-export-with-sub-superscripts nil
                    org-special-ctrl-a/e t
                    org-special-ctrl-k t
                    org-yank-adjusted-subtrees t)
             )
)


  ; Inline images in HTML instead of producting links to the image
  (setq org-export-html-inline-images t)
  (setq org-export-with-sub-superscripts nil)

  (require 'ox-taskjuggler)
  (require 'ox-confluence)

  (add-to-list 'org-export-backends 'taskjuggler)
  (add-to-list 'org-export-backends 'confluence)
  (setq org-export-html-style-include-default t)
  ; Do not generate internal css formatting for HTML exports
  (setq org-export-htmlize-output-type (quote css))
  ; Export with LaTeX fragments
  (setq org-export-with-LaTeX-fragments t)

  (setq org-return-follows-link t
        org-tab-follows-link t
        org-src-fontify-natively t)

  (setq org-hide-leading-stars nil
        org-cycle-separator-lines 2)

  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)


  (setq org-agenda-files `(
                           ,(concat org-directory "/gtd.org")
                           ,(concat org-directory "/tech.org")))

  (setq org-stuck-projects '( "HOLD|SOMEDAY|+SCHEDULED<\"<today>\"" ( "DONE" "CLOSED" "CANCELLED") nil "" ))
  (setq org-archive-location (concat org-directory "/archive.org::Archive"))

  (setq org-default-notes-file (concat org-directory "/notes.org"))
  (setq org-special-ctrl-a/e t)
  (setq org-return-follows-link nil)
  (setq org-fast-tag-selection-single-key t)

  (setq org-tag-alist '(
                        ("@home" . ?h)
                        ("@office" . ?o)
                        ("@phone" . ?p)
                        ("crypt" . ?s)
                        ("@toread" . ?r)
                        ("personal" . ?x)))

  (setq org-log-done 'time)


                                          ; Use IDO for target completion
  (setq org-completion-use-ido t)

  (setq org-refile-use-outline-path nil)
  (setq org-refile-targets (quote ((org-agenda-files :level . 1))))
  (setq org-outline-path-complete-in-steps nil)

#+END_SRC
*** Exporting documents
Here we configure the export formats we need.
#+BEGIN_SRC emacs-lisp

(require 'ox-html)
(require 'ox-md)
(require 'ox-ascii)
(require 'ox-org)
(require 'ox-confluence)
(require 'ox-latex)

(require 'org-crypt)
(setq org-crypt-key "Andrew Gavin")

(org-crypt-use-before-save-magic)
;;(setq org-tags-exclude-from-inheritance (quote ("crypt")))


;; Add feeds here
;;
(setq org-feed-alist
      '(("Slashdot"
         "http://rss.slashdot.org/Slashdot/slashdot"
         "~/org/feeds.org" "Slashdot Entries")))



(add-hook 'org-mode-hook
          (lambda ()
            (writegood-mode)
            (company-mode)
            (yas-minor-mode)
            (set (make-local-variable 'company-backends)
               '((company-dabbrev-code company-gtags company-etags
                  company-keywords company-files company-dabbrev
                  company-yasnippet)))))


(defvar org-journal-file "~/Documents/org/journal.org"
  "Path to OrgMode journal file.")
(defvar org-journal-date-format "%Y-%m-%d"
  "Date format string for journal headings.")

(defun org-journal-entry ()
  "Create a new diary entry for today or append to an existing one."
  (interactive)
  (switch-to-buffer (find-file org-journal-file))
  (widen)
  (let ((today (format-time-string org-journal-date-format)))
    (beginning-of-buffer)
    (unless (org-goto-local-search-forward-headings today nil t)
      ((lambda ()
         (org-insert-heading)
         (insert today)
         (insert "\n\n  \n"))))
    (beginning-of-buffer)
    (org-show-entry)
    (org-narrow-to-subtree)
    (end-of-buffer)
    (backward-char 2)
    (unless (= (current-column) 2)
      (insert "\n\n  "))))

#+end_src
*** Keeping track of references
Bibtex can be useful for keeping track of books and articles that you
have read in an easy text format.  Then this is easy for citation in
presentation handouts.  When a document uses references in a bibtex
file latex may need running multiple times.  To make this process
easier we can change the export command to use a script that detects
the executions needed to format the document.
#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process (list "latexmk -f -pdf %f"))
#+END_SRC
** Presentations
*** For code in the editor
Sometimes during presentations and we need to change the font. We can
define some conventional keys for changing the font pitch:

#+begin_src emacs-lisp
(define-key global-map (kbd "C-+") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)
#+end_src

*** Producing Slides

Org-mode does export to latex's beamer package to create slides.  This
is configurable entirely from the file itself.  However here we set
our preferred style.

#+begin_src emacs-lisp
(setq org-beamer-theme "CambridgeUS")
#+end_src

At the moment I'm prefering the following presentation options.

#+begin_example
#+BEAMER_THEME: CambridgeUS
#+BEAMER_COLOR_THEME: dove


#+OPTIONS: H:2 toc:t

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
#+end_example
*** Handouts

Technical presentations are all well and good, but often a practical
element is best to really give the audience the knowlege that you
indend to convay.  For a more workshop like presentation it is useful
to produce a set of handouts to accompany the practical session.
Latex has a really good package: [[https://tufte-latex.github.io/tufte-latex/][Tufte-latex]].  Which takes it's
inspiration from the typography of /Edward Tufte/.  Here we're setting
up a hand-out format for org-mode:
#+BEGIN_SRC emacs-lisp
;;  (eval-after-load 'ox-latex
;;    (add-to-list 'org-latex-classes '( "handout"
;;                                       "\\documentclass{tufte-handout}"
;;                                       ("\\section{%s}" . "\\section*{%s}")
;;                                       ("\\subsection{%s}" . "\\subsection*{%s}")
;;                                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
;;                                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC


* EPA

#+begin_src emacs-lisp
;;(require 'epa-setup)

;;(epa-file-enable)
;;(setq epa-file-cache-passphrase-for-symmetric-encryption t)

;;(setq config-private-loaded nil)
;;(defun config-private-eval (p)
;;  (unless config-private-loaded
;;	 (load "~/private.gpg")
;;	 (setq config-private-loaded t))
;;  (eval p))

#+end_src

* Emacs client support

Some applications require an editor or even some functions that emacs
can supply.  Emacsclient instructs the existing emacs session to do
this work, avoiding starting anothe emacs session.  To enable this we
have to set the emacs instance up as a server.

#+begin_src emacs-lisp
(unless (and (fboundp 'server-running-p)
             (server-running-p))
 (server-start))
#+end_src
* My functions
Load my personal functions
#+BEGIN_SRC emacs-lisp
(require 'andy-fn)
#+END_SRC
